var _apiKey, _statisticsToken, _instance;
import { __awaiter, __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import axios from 'axios';
import getInstance from './axios-instance.js';
export default class {
    constructor(apiKey, settings) {
        _apiKey.set(this, void 0);
        _statisticsToken.set(this, void 0);
        _instance.set(this, void 0);
        this.baseURL = 'https://suppliers-api.wildberries.ru/';
        __classPrivateFieldSet(this, _apiKey, apiKey, "f");
        __classPrivateFieldSet(this, _statisticsToken, (settings === null || settings === void 0 ? void 0 : settings.statisticsToken) || '', "f");
        __classPrivateFieldSet(this, _instance, getInstance({
            baseURL: (settings && settings.baseURL) || this.baseURL,
            apiKey: __classPrivateFieldGet(this, _apiKey, "f"),
        }), "f");
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                       СКЛАДЫ                                                       */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Возвращает список складов поставщика
     */
    getWarehouses() {
        return __classPrivateFieldGet(this, _instance, "f") //
            .get(`/api/v2/warehouses`)
            .then(response => response.data || []);
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                       ЗАКАЗЫ                                                       */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Возвращает список сборочных заданий поставщика без пагинации.
     * @param options
     */
    getOrdersAll(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let skip = options.skip || 0;
            let take = options.take || 100;
            let total = 1;
            const orders = [];
            if (!Number.isInteger(take))
                throw 'take must be integer ' + take;
            if (take < 1)
                throw 'take must be positive';
            if (!Number.isInteger(skip))
                throw 'skip must be integer ' + skip;
            if (skip < 0)
                throw 'skip must be not negative';
            while (skip < total) {
                const result = yield this.getOrders(Object.assign(Object.assign({}, options), { skip,
                    take }));
                orders.push(...result.orders);
                total = result.total;
                skip += take;
            }
            return orders;
        });
    }
    /**
     * Возвращает список сборочных заданий поставщика.
     * @param options
     */
    getOrders(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .get(`/api/v2/orders`, {
            params: options,
        })
            .then(response => response.data);
    }
    /**
     * Возвращает список стикеров по переданному массиву сборочных заданий.
     * Нельзя запросить больше 1000 стикеров за раз.
     */
    getOrdersStickers(orderIds) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/api/v2/orders/stickers`, { orderIds })
            .then(response => response.data);
    }
    /**
     * Возвращает один стикер по переданному номеру сборочного задания.
     */
    getOrdersStickersPdf(orderId) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/api/v2/orders/stickers/pdf`, { orderId })
            .then(response => response.data);
    }
    /**
     * Обновляет статус переданных сборочных заданий.
     * @param orders
     */
    putOrders(orders) {
        console.log(JSON.stringify(orders, null, '  '));
        return __classPrivateFieldGet(this, _instance, "f") //
            .put(`/api/v2/orders`, orders)
            .then(response => response.data)
            .then(data => {
            if (data.error)
                throw data;
        });
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                       ОСТАТКИ                                                      */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Возвращает список товаров поставщика с их остатками без пагинации
     * @param options
     */
    getStocks(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .get(`/api/v2/stocks`, {
            params: options,
        })
            .then(response => response.data);
    }
    /**
     * Возвращает список товаров поставщика с их остатками
     * @param options
     */
    getStocksAll(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let skip = (options && options.skip) || 0;
            let take = (options && options.take) || 100;
            let total = 1;
            const stocks = [];
            if (!Number.isInteger(take))
                throw 'take must be integer ' + take;
            if (take < 1)
                throw 'take must be positive';
            if (!Number.isInteger(skip))
                throw 'skip must be integer ' + skip;
            if (skip < 0)
                throw 'skip must be not negative';
            while (skip < total) {
                const result = yield this.getStocks(Object.assign(Object.assign({}, options), { skip,
                    take }));
                stocks.push(...(result.stocks || []));
                total = result.total;
                skip += take;
            }
            return stocks;
        });
    }
    /**
     * Обновляет остатки товаров
     * @param stocks
     */
    postStocks(stocks) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/api/v2/stocks`, stocks)
            .then(response => response.data)
            .then(data => {
            if (data.error)
                throw data;
        });
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                        ЦЕНЫ                                                        */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Загрузка цен. За раз можно загрузить не более 1000 номенклатур.
     * @param prices
     * @returns
     */
    postPrices(prices) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/public/api/v1/prices`, prices)
            .then(response => response);
    }
    /**
     * Получение информации по номенклатурам, их ценам, скидкам и промокодам. Если не указывать фильтры, вернётся весь товар.
     * @param quantity
     * @returns
     */
    getInfo(quantity) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .get(`/public/api/v1/info`, {
            params: {
                quantity,
            },
        })
            .then(response => response.data);
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                   ПРОМОКОДЫ И СКИДКИ                                               */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Установка скидок для номенклатур. Максимальное количество номенклатур на запрос - 1000
     * @param options
     */
    updateDiscounts(options, activateFrom) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/public/api/v1/updateDiscounts`, options, {
            params: activateFrom,
        })
            .then(response => response.data);
    }
    /**
     * Сброс скидок для номенклатур
     * @param options
     */
    revokeDiscounts(nmIDs) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/public/api/v1/revokeDiscounts`, nmIDs)
            .then(response => response.data);
    }
    /**
     * Установка промокодов для номенклатур. Максимальное количество номенклатур на запрос - 1000
     * @param options
     */
    updatePromocodes(options, activateFrom) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/public/api/v1/updatePromocodes`, options, {
            params: activateFrom,
        })
            .then(response => response.data);
    }
    /**
     * Сброс скидок для номенклатур
     * @param options
     */
    revokePromocodes(nmIDs) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/public/api/v1/revocePromocodes`, nmIDs)
            .then(response => response.data);
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                         КАРТОЧКИ                                                   */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Создаёт группу новых карточек.
     * @param options
     */
    batchCreate(cards) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/batchCreate`, cards)
            .then(response => response.data);
    }
    /**
     * Получение карточки поставщика по imt id
     * @param options
     */
    cardByImtID(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/cardByImtID`, options)
            .then(response => response.data);
    }
    /**
     * Создаёт одну новую карточку.
     * @param options
     */
    cardCreate(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/create`, options)
            .then(response => response.data);
    }
    /**
     * Удаляет одну номенклатуру из карточки товара
     * @param options
     */
    deleteNomenclature(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/deleteNomenclature`, options)
            .then(response => response.data);
    }
    /**
     * Позволяет выгружать файлы из хранилища. data содержит массив байт, который является файлом.
     * @param options
     */
    getCardFile(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .get(`/card/file​`, {
            params: options,
        })
            .then(response => response.data);
    }
    /**
     * Позволяет сгенерировать шк для размера
     * @param options
     */
    getBarcodes(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/getBarcodes`, options)
            .then(response => response.data);
    }
    /**
     * Возвращает список карточек товаров
     * @param options
     */
    getCardsAll(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let skip = (options && options.skip) || 0;
            let take = (options && options.take) || 100;
            let total = 1;
            const cards = [];
            if (!Number.isInteger(take))
                throw 'take must be integer ' + take;
            if (take < 1)
                throw 'take must be positive';
            if (!Number.isInteger(skip))
                throw 'skip must be integer ' + skip;
            if (skip < 0)
                throw 'skip must be not negative';
            while (skip < total) {
                const result = yield this.cardList({
                    id: 1,
                    jsonrpc: '2.0',
                    params: {
                        query: {
                            limit: take,
                            offset: skip,
                        },
                    },
                });
                cards.push(...(result.result.cards || []));
                if ((_a = result.result.cursor) === null || _a === void 0 ? void 0 : _a.total)
                    total = (_b = result.result.cursor) === null || _b === void 0 ? void 0 : _b.total;
                skip += take;
                console.log(`${cards.length}/${total}`);
            }
            return cards;
        });
    }
    makeCardsFlat(cards) {
        var _a;
        for (let i = 0; i <= cards.length - 1; i++) {
            const card = cards[i];
            if (!card.nomenclatures)
                continue;
            const _nomenclature = card.nomenclatures.shift();
            if (!_nomenclature)
                continue;
            // @ts-ignore
            card._nomenclature = _nomenclature;
            if (card.nomenclatures.length) {
                cards.splice(i + 1, 0, JSON.parse(JSON.stringify(card)));
            }
            else {
                delete card.nomenclatures;
            }
            // @ts-ignore
            const _variation = (_a = _nomenclature.variations) === null || _a === void 0 ? void 0 : _a.shift();
            if (!_variation)
                continue;
            // @ts-ignore
            _nomenclature._variation = _variation;
            // @ts-ignore
            if (_nomenclature.variations.length) {
                cards.splice(i + 1, 0, JSON.parse(JSON.stringify(card)));
            }
            else {
                // @ts-ignore
                delete _nomenclature.variations;
            }
            if (card.addin) {
                card._addin = this.getAddinObject(card);
            }
            if (card._nomenclature && card._nomenclature.addin) {
                card._nomenclature._addin = this.getAddinObject(card._nomenclature);
            }
            if (card._nomenclature._variation && card._nomenclature._variation.addin) {
                card._nomenclature._variation._addin = this.getAddinObject(card._nomenclature);
            }
        }
        return cards;
    }
    getAddinObject(item) {
        return item.addin.reduce((acc, item) => {
            acc[item.type.replace(/\s/g, '_')] = item === null || item === void 0 ? void 0 : item.params.map(x => x.value);
            return acc;
        }, {});
    }
    /**
     * Позволяет получить массив карточек товаров, удовлетворяющих фильтру и с указанной сортировкой.
     * order - порядок отображения карточек. Может принимать значения asc или desc.
     * sort - какие columns и с какими excludedValues исключить.
     * find - поиск карточке с определённым search(значением) в определённом columns.
     * query позволяет получать не все карточки сразу:
     * limit - сколько карточек максимум вывести,
     * offset - сколько карточек от самой первой пропустить.
     * @param options
     */
    cardList(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/list`, options)
            .then(response => response.data);
    }
    /**
     * Позволяет обновлять карточку товара. Карточка с определённым ID изменяется на ту, которую прислали.
     * @param options
     */
    cardUpdate(options) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/update`, options)
            .then(response => response.data);
    }
    /**
     * Позволяет загружать файлы в хранилище.
     * fileID заполняется из названия файла.
     * data заполняется из параметра uploadfile.
     * @param options
     */
    cardUploadFileMultipart(options, xFileId) {
        return __classPrivateFieldGet(this, _instance, "f") //
            .post(`/card/upload/file/multipart`, options, {
            params: xFileId,
        })
            .then(response => response.data);
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                  СЕРВЕР СТАТИСТИКИ                                                 */
    /* ------------------------------------------------------------------------------------------------------------------ */
    getReportDetail(dateFrom, dateTo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!__classPrivateFieldGet(this, _statisticsToken, "f"))
                throw 'Метод доступен только если во время инициализации был передан statisticsToken ';
            let rows = [];
            let rrdid = 0;
            while (typeof rrdid === 'number') {
                yield this.getReportDetailChunk(dateFrom, dateTo, rrdid).then(data => {
                    if (!data || data.length === 0) {
                        rrdid = null;
                    }
                    else {
                        rows.push(...data);
                        rrdid = data[data.length - 1].rrd_id;
                    }
                });
            }
            return rows;
        });
    }
    getReportDetailChunk(dateFrom, dateTo, rrdid) {
        return __awaiter(this, void 0, void 0, function* () {
            return axios //
                .get(`https://suppliers-stats.wildberries.ru/api/v1/supplier/reportDetailByPeriod`, {
                params: {
                    dateFrom,
                    dateTo,
                    rrdid,
                    limit: 10000,
                    key: __classPrivateFieldGet(this, _statisticsToken, "f"),
                },
            })
                .then(response => response.data);
        });
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                              FULFILLED BY WILDBERRIES                                              */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /** Получает список поставок с сервера статистики */
    getFbwIncomes(dateFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            return axios //
                .get(`https://suppliers-stats.wildberries.ru/api/v1/supplier/incomes`, {
                params: {
                    dateFrom,
                    key: __classPrivateFieldGet(this, _statisticsToken, "f"),
                },
            })
                .then(response => response.data);
        });
    }
    /** Получает список остатков с сервера статистики */
    getFbwStocks(dateFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            return axios //
                .get(`https://suppliers-stats.wildberries.ru/api/v1/supplier/stocks`, {
                params: {
                    dateFrom,
                    key: __classPrivateFieldGet(this, _statisticsToken, "f"),
                },
            })
                .then(response => response.data);
        });
    }
    /** Получает список заказов с сервера статистики */
    getFbwOrders(dateFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            return axios //
                .get(`https://suppliers-stats.wildberries.ru/api/v1/supplier/orders`, {
                params: {
                    dateFrom,
                    key: __classPrivateFieldGet(this, _statisticsToken, "f"),
                },
            })
                .then(response => response.data);
        });
    }
    /** Получает список продаж с сервера статистики */
    getFbwSales(dateFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            return axios //
                .get(`https://suppliers-stats.wildberries.ru/api/v1/supplier/sales`, {
                params: {
                    dateFrom,
                    key: __classPrivateFieldGet(this, _statisticsToken, "f"),
                },
            })
                .then(response => response.data);
        });
    }
    /* ------------------------------------------------------------------------------------------------------------------ */
    /*                                                FULLFILLED BY SELLER                                                */
    /* ------------------------------------------------------------------------------------------------------------------ */
    /**
     * Возвращает список сборочных заданий поставщика без пагинации.
     * @param options
     */
    getFbsOrders(dateFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            let skip = 0;
            let take = 1000;
            let total = 1;
            const orders = [];
            while (skip < total) {
                const result = yield __classPrivateFieldGet(this, _instance, "f")
                    .get(`/api/v2/orders`, {
                    params: {
                        date_start: dateFrom,
                        take,
                        skip,
                    },
                })
                    .then(response => response.data);
                orders.push(...result.orders);
                total = result.total;
                skip += take;
            }
            return orders;
        });
    }
}
_apiKey = new WeakMap(), _statisticsToken = new WeakMap(), _instance = new WeakMap();
//# sourceMappingURL=index.js.map